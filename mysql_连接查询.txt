一、连接查询
	1.等值连接
		select 字段A,字段B（列表） from 表A,表B,...where 连接条件 [其他筛选条件];
		
		select * from emp where (job,sal) in (select job,sal from emp where ename='MARTIN');

		
	2.内连接（与等值相比效率较高）
		select 字段列表 from 表A inner join 表B on 连接条件 [其他筛选条件] (inner join 表n on 连接条件....)；
	
	3.外连接
		左外连接：(left join):
			语法：select 字段列表 from 表A left join 表B on 连接条件 [其他筛选条件];
				  左外连接的查询结果包括所有符合连接条件的记录信息，和左表中不符合连接条件的记录。
		右外连接：(right join):
			语法：select 字段列表 from 表A right join 表B on 连接条件 [其他筛选条件];
 11               右外连接的查询结果包括所有符合连接条件的记录信息，和右表中不符合连接条件的记录。
			eg: select stuname,sex,score, shoolname from school left join student on school_id=student_id;



二、 当遇到子查询的时候该做虾米：
	子查询（嵌套查询）
		·一般用括号括起来，在sql语句中一般会先执行子查询！
		·子查询的结果经常会作为外部查询的条件
		
		·子查询中常用的关键字：
							 in : 用于匹配某些字段值 是否在 子查询结果集 中！
							 all: 用于判断字段值 是否与 子查询结果集中的所有记录值的大小。
							 any: 用于判断字段值 是否与 子查询结果集合中的任何一个记录值的大小。

三、事务（trans action）
	transaction: 具有一系列操作的逻辑工作单元，这个逻辑工作单元中的所有操作作为一个整体，要么全部成功，否则全部失败。
	事务的特性（ACID）：
	A: atom i city (原子性) “不可再分项”，事务中的所有操作作为一个整体不可再分。要么全成功，要么全失败。
	C: consis tency (一致性) “从一种平衡状态到另一种平衡状态”，事务操作前后，系统数据的状态从一种 consistency 到 另一种 consistency 。 	
	I: Iso lation (隔离性) “例如换衣间”，数据库系统可以被多个事务并发操作，在一个事务操作的过程中，其他事务不能查看其 “操作的过程” ，只能查看操作成功 之前 或 之后 的状态。
		针对隔离性，事务有四种隔离级别 ：
										read uncommitted (读未提交级别：低)--->
											  read committed (读提交级别:中)------> 
													repeatable (可重读级别:较高)------>
															 serializable (串行化级别:最高)
	
	D: Durability (持久性) 事务一旦提交，则对数据库系统的影响 是持久的。 

四、事务锁 (数据库锁)：
	从读写的角度看，锁可以被分为两大类：
	读锁(共享锁)、写锁(排他锁)。
	
	一个事物对某些数据加了 读锁 后，其他事务也可以对这些数据 加读锁，但不能对这些数据加 写锁。

	一个事务对某些数据加了 写锁 后，其他事务对这些数据既不能加 读锁，也不能 加写锁。

	一般情况下，在操作数据库的过程中，不必显示加锁，因为DBMS会在合适的地方为用户为事务加锁。

	·加读锁的情况：
				select 字段列表 from 表名称 [过滤条件] lock in share mode;
	 注意：在事务的 “ serializable ” 中 ，普通的 select 语句也会加 读锁。

	·加写锁的方法：
				update、delete、rename、等语句。
				select 字段名 from 表名称 [过滤条件] for update;

1.begin; 或  start tansaction; # 事务的开始；

2.rollback; # 回滚(撤销整个事务)；

3.commit; # 事务的提交；

4.savepoint 保存点名称; # 保存点(保存事务);

5.rollback to 保存点名称;

6.设置当前会话（连接）的事务隔离级别
set session transaction isolation level [read uncommited|read commited|repeatable|serializable];

7.查看当前事务级别：select @@tx_isolation; # 全局的事务等级
					select @tx_isolation   # 用户的事务等级

 
五、事务的隔离级别
	脏读：一个事务读取到了另一个事务还未提交的数据，这种现象叫“脏读”，读取到未提交的数据叫“脏数据”！

	不可重读：一个事务中两次读取的数据不一致的现象；
	幻读：一个事务中两次读取的数据记录数（条数）不一致的现象
	
	四个级别逐渐增强，每个级别解决一个问题。
	
	脏读：最容易理解。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。

	不重复读：解决了脏读后，会遇到，同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。
	
	幻读：解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。

·借鉴并改造了一个搞笑的比喻：
	脏读：假如，中午去食堂打饭吃，看到一个座位被同学小Q占上了，就认为这个座位被占去了，就转身去找其他的座位。不料，这个同学小Q起身走了。事实：该同学小Q只是临时坐了一小下，并未“提交”。
	不重复读：假如，中午去食堂打饭吃，看到一个座位是空的，便屁颠屁颠的去打饭，回来后却发现这个座位却被同学小Q占去了。
	幻读：假如，中午去食堂打饭吃，看到一个座位是空的，便屁颠屁颠的去打饭，回来后，发现这些座位都还是空的（重复读），窃喜。走到跟前刚准备坐下时，却惊现一个恐龙妹，严重影响食欲。仿佛之前看到的空座位是“幻影”一样。

-------------------------------------------------------------------------------------------------------------
	· read uncommitted level # 设置此级别的事务可能会发生脏读、不可重读、幻读现象！
	· read committed level # 设置了该隔离级别的事务可能会发生不可重读或幻读现象！
	· repeatable level # MySQL默认的事务隔离级别，设置了该隔离级别的事务，解决了脏读、不可重读的现象，而且Inn	   oDB数据库存储引擎也帮助解决了幻读的问题。
	· serializable level # 在普通的select语句也会加读锁。 
-------------------------------------------------------------------------------------------------------------
